Terminaux inutilisés dans la grammaire

    LS_EQ
    GR_EQ
    LEFT_ASSIGN
    RIGHT_ASSIGN
    AND_ASSIGN
    XOR_ASSIGN
    OR_ASSIGN
    CONST


Grammaire

    0 $accept: starter $end

    1 starter: starter builder
    2        | builder

    3 builder: function
    4        | declaration

    5 function: type IDENTIFIER '(' argument_list ')' bloc_stmt

    6 type: data_type pointer
    7     | data_type

    8 pointer: '*' pointer
    9        | '*'

   10 data_type: sign_specifier type_specifier
   11          | type_specifier

   12 sign_specifier: SIGNED
   13               | UNSIGNED

   14 type_specifier: INT
   15               | SHORT INT
   16               | SHORT
   17               | LONG
   18               | LONG INT
   19               | LONG_LONG
   20               | LONG_LONG INT

   21 argument_list: arguments
   22              | %empty

   23 arguments: arguments ',' arg
   24          | arg

   25 arg: type IDENTIFIER

   26 stmt: bloc_stmt
   27     | single_stmt

   28 bloc_stmt: '{' statements '}'

   29 statements: statements stmt
   30           | %empty

   31 single_stmt: if_block
   32            | for_block
   33            | while_block
   34            | declaration
   35            | function_call ';'
   36            | RETURN ';'
   37            | CONTINUE ';'
   38            | BREAK ';'
   39            | RETURN condition ';'

   40 for_block: FOR '(' expression_stmt expression_stmt ')' stmt
   41          | FOR '(' expression_stmt expression_stmt expression ')' stmt

   42 if_block: IF '(' expression ')' stmt
   43         | IF '(' expression ')' stmt ELSE stmt

   44 while_block: WHILE '(' expression ')' stmt

   45 declaration: type declaration_list ';'
   46            | declaration_list ';'
   47            | unary_expr ';'

   48 declaration_list: declaration_list ',' sub_decl
   49                 | sub_decl

   50 sub_decl: assignment_expr
   51         | IDENTIFIER
   52         | array_index

   53 expression_stmt: expression ';'
   54                | ';'

   55 expression: expression ',' condition
   56           | condition

   57 condition: condition '>' condition
   58          | condition '<' condition
   59          | condition EQ condition
   60          | condition NOT_EQ condition
   61          | condition L_EQ condition
   62          | condition G_EQ condition
   63          | condition LOGICAL_AND condition
   64          | condition LOGICAL_OR condition
   65          | '!' condition
   66          | arithmetic_expr
   67          | assignment_expr
   68          | unary_expr

   69 assignment_expr: lhs assign_op arithmetic_expr
   70                | lhs assign_op array_index
   71                | lhs assign_op function_call
   72                | lhs assign_op unary_expr
   73                | unary_expr assign_op unary_expr

   74 unary_expr: lhs INCREMENT
   75           | lhs DECREMENT
   76           | DECREMENT lhs
   77           | INCREMENT lhs

   78 lhs: IDENTIFIER

   79 assign_op: '='
   80          | ADD_ASSIGN
   81          | SUB_ASSIGN
   82          | MUL_ASSIGN
   83          | DIV_ASSIGN
   84          | MOD_ASSIGN

   85 arithmetic_expr: arithmetic_expr '+' arithmetic_expr
   86                | arithmetic_expr '-' arithmetic_expr
   87                | arithmetic_expr '*' arithmetic_expr
   88                | arithmetic_expr '/' arithmetic_expr
   89                | arithmetic_expr '%' arithmetic_expr
   90                | '(' arithmetic_expr ')'
   91                | '-' arithmetic_expr
   92                | IDENTIFIER
   93                | constant

   94 constant: DEC_CONSTANT
   95         | HEX_CONSTANT

   96 array_index: IDENTIFIER '[' condition ']'

   97 function_call: IDENTIFIER '(' parameter_list ')'
   98              | IDENTIFIER '(' ')'

   99 parameter_list: parameter_list ',' parameter
  100               | parameter

  101 parameter: condition
  102          | STRING


Terminaux, suivis des règles où ils apparaissent

    $end (0) 0
    '!' (33) 65
    '%' (37) 89
    '(' (40) 5 40 41 42 43 44 90 97 98
    ')' (41) 5 40 41 42 43 44 90 97 98
    '*' (42) 8 9 87
    '+' (43) 85
    ',' (44) 23 48 55 99
    '-' (45) 86 91
    '/' (47) 88
    ';' (59) 35 36 37 38 39 45 46 47 53 54
    '<' (60) 58
    '=' (61) 79
    '>' (62) 57
    '[' (91) 96
    ']' (93) 96
    '{' (123) 28
    '}' (125) 28
    error (256)
    IDENTIFIER <entry> (258) 5 25 51 78 92 96 97 98
    DEC_CONSTANT <dval> (259) 94
    HEX_CONSTANT <dval> (260) 95
    STRING (261) 102
    LOGICAL_AND (262) 63
    LOGICAL_OR (263) 64
    LS_EQ (264)
    GR_EQ (265)
    EQ (266) 59
    NOT_EQ (267) 60
    MUL_ASSIGN (268) 82
    DIV_ASSIGN (269) 83
    MOD_ASSIGN (270) 84
    ADD_ASSIGN (271) 80
    SUB_ASSIGN (272) 81
    LEFT_ASSIGN (273)
    RIGHT_ASSIGN (274)
    AND_ASSIGN (275)
    XOR_ASSIGN (276)
    OR_ASSIGN (277)
    INCREMENT (278) 74 77
    DECREMENT (279) 75 76
    SHORT (280) 15 16
    INT (281) 14 15 18 20
    LONG (282) 17 18
    LONG_LONG (283) 19 20
    SIGNED (284) 12
    UNSIGNED (285) 13
    CONST (286)
    IF (287) 42 43
    FOR (288) 40 41
    WHILE (289) 44
    CONTINUE (290) 37
    BREAK (291) 38
    RETURN (292) 36 39
    L_EQ (293) 61
    G_EQ (294) 62
    UMINUS (295)
    LOWER_THAN_ELSE (296)
    ELSE (297) 43


Non-terminaux, suivis des règles où ils apparaissent

    $accept (60)
        à gauche: 0
    starter (61)
        à gauche: 1 2
        à droite: 0 1
    builder (62)
        à gauche: 3 4
        à droite: 1 2
    function (63)
        à gauche: 5
        à droite: 3
    type (64)
        à gauche: 6 7
        à droite: 5 25 45
    pointer (65)
        à gauche: 8 9
        à droite: 6 8
    data_type (66)
        à gauche: 10 11
        à droite: 6 7
    sign_specifier (67)
        à gauche: 12 13
        à droite: 10
    type_specifier (68)
        à gauche: 14 15 16 17 18 19 20
        à droite: 10 11
    argument_list (69)
        à gauche: 21 22
        à droite: 5
    arguments (70)
        à gauche: 23 24
        à droite: 21 23
    arg (71)
        à gauche: 25
        à droite: 23 24
    stmt (72)
        à gauche: 26 27
        à droite: 29 40 41 42 43 44
    bloc_stmt (73)
        à gauche: 28
        à droite: 5 26
    statements (74)
        à gauche: 29 30
        à droite: 28 29
    single_stmt (75)
        à gauche: 31 32 33 34 35 36 37 38 39
        à droite: 27
    for_block (76)
        à gauche: 40 41
        à droite: 32
    if_block (77)
        à gauche: 42 43
        à droite: 31
    while_block (78)
        à gauche: 44
        à droite: 33
    declaration (79)
        à gauche: 45 46 47
        à droite: 4 34
    declaration_list (80)
        à gauche: 48 49
        à droite: 45 46 48
    sub_decl (81)
        à gauche: 50 51 52
        à droite: 48 49
    expression_stmt (82)
        à gauche: 53 54
        à droite: 40 41
    expression <dval> (83)
        à gauche: 55 56
        à droite: 41 42 43 44 53 55
    condition <dval> (84)
        à gauche: 57 58 59 60 61 62 63 64 65 66 67 68
        à droite: 39 55 56 57 58 59 60 61 62 63 64 65 96 101
    assignment_expr <dval> (85)
        à gauche: 69 70 71 72 73
        à droite: 50 67
    unary_expr <dval> (86)
        à gauche: 74 75 76 77
        à droite: 47 68 72 73
    lhs <entry> (87)
        à gauche: 78
        à droite: 69 70 71 72 74 75 76 77
    assign_op <ival> (88)
        à gauche: 79 80 81 82 83 84
        à droite: 69 70 71 72 73
    arithmetic_expr <dval> (89)
        à gauche: 85 86 87 88 89 90 91 92 93
        à droite: 66 69 85 86 87 88 89 90 91
    constant <dval> (90)
        à gauche: 94 95
        à droite: 93
    array_index (91)
        à gauche: 96
        à droite: 52 70
    function_call (92)
        à gauche: 97 98
        à droite: 35 71
    parameter_list (93)
        à gauche: 99 100
        à droite: 97 99
    parameter (94)
        à gauche: 101 102
        à droite: 99 100


État 0

    0 $accept: . starter $end

    IDENTIFIER  décalage et aller à l'état 1
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9

    starter           aller à l'état 10
    builder           aller à l'état 11
    function          aller à l'état 12
    type              aller à l'état 13
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    declaration       aller à l'état 17
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23


État 1

   51 sub_decl: IDENTIFIER .
   78 lhs: IDENTIFIER .
   96 array_index: IDENTIFIER . '[' condition ']'

    '['  décalage et aller à l'état 24

    ','       réduction par utilisation de la règle 51 (sub_decl)
    ';'       réduction par utilisation de la règle 51 (sub_decl)
    $défaut  réduction par utilisation de la règle 78 (lhs)


État 2

   77 unary_expr: INCREMENT . lhs

    IDENTIFIER  décalage et aller à l'état 25

    lhs  aller à l'état 26


État 3

   76 unary_expr: DECREMENT . lhs

    IDENTIFIER  décalage et aller à l'état 25

    lhs  aller à l'état 27


État 4

   15 type_specifier: SHORT . INT
   16               | SHORT .

    INT  décalage et aller à l'état 28

    $défaut  réduction par utilisation de la règle 16 (type_specifier)


État 5

   14 type_specifier: INT .

    $défaut  réduction par utilisation de la règle 14 (type_specifier)


État 6

   17 type_specifier: LONG .
   18               | LONG . INT

    INT  décalage et aller à l'état 29

    $défaut  réduction par utilisation de la règle 17 (type_specifier)


État 7

   19 type_specifier: LONG_LONG .
   20               | LONG_LONG . INT

    INT  décalage et aller à l'état 30

    $défaut  réduction par utilisation de la règle 19 (type_specifier)


État 8

   12 sign_specifier: SIGNED .

    $défaut  réduction par utilisation de la règle 12 (sign_specifier)


État 9

   13 sign_specifier: UNSIGNED .

    $défaut  réduction par utilisation de la règle 13 (sign_specifier)


État 10

    0 $accept: starter . $end
    1 starter: starter . builder

    $end        décalage et aller à l'état 31
    IDENTIFIER  décalage et aller à l'état 1
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9

    builder           aller à l'état 32
    function          aller à l'état 12
    type              aller à l'état 13
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    declaration       aller à l'état 17
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23


État 11

    2 starter: builder .

    $défaut  réduction par utilisation de la règle 2 (starter)


État 12

    3 builder: function .

    $défaut  réduction par utilisation de la règle 3 (builder)


État 13

    5 function: type . IDENTIFIER '(' argument_list ')' bloc_stmt
   45 declaration: type . declaration_list ';'

    IDENTIFIER  décalage et aller à l'état 33
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3

    declaration_list  aller à l'état 34
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 35
    lhs               aller à l'état 22
    array_index       aller à l'état 23


État 14

    6 type: data_type . pointer
    7     | data_type .

    '*'  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 7 (type)

    pointer  aller à l'état 37


État 15

   10 data_type: sign_specifier . type_specifier

    SHORT      décalage et aller à l'état 4
    INT        décalage et aller à l'état 5
    LONG       décalage et aller à l'état 6
    LONG_LONG  décalage et aller à l'état 7

    type_specifier  aller à l'état 38


État 16

   11 data_type: type_specifier .

    $défaut  réduction par utilisation de la règle 11 (data_type)


État 17

    4 builder: declaration .

    $défaut  réduction par utilisation de la règle 4 (builder)


État 18

   46 declaration: declaration_list . ';'
   48 declaration_list: declaration_list . ',' sub_decl

    ','  décalage et aller à l'état 39
    ';'  décalage et aller à l'état 40


État 19

   49 declaration_list: sub_decl .

    $défaut  réduction par utilisation de la règle 49 (declaration_list)


État 20

   50 sub_decl: assignment_expr .

    $défaut  réduction par utilisation de la règle 50 (sub_decl)


État 21

   47 declaration: unary_expr . ';'
   73 assignment_expr: unary_expr . assign_op unary_expr

    MUL_ASSIGN  décalage et aller à l'état 41
    DIV_ASSIGN  décalage et aller à l'état 42
    MOD_ASSIGN  décalage et aller à l'état 43
    ADD_ASSIGN  décalage et aller à l'état 44
    SUB_ASSIGN  décalage et aller à l'état 45
    '='         décalage et aller à l'état 46
    ';'         décalage et aller à l'état 47

    assign_op  aller à l'état 48


État 22

   69 assignment_expr: lhs . assign_op arithmetic_expr
   70                | lhs . assign_op array_index
   71                | lhs . assign_op function_call
   72                | lhs . assign_op unary_expr
   74 unary_expr: lhs . INCREMENT
   75           | lhs . DECREMENT

    MUL_ASSIGN  décalage et aller à l'état 41
    DIV_ASSIGN  décalage et aller à l'état 42
    MOD_ASSIGN  décalage et aller à l'état 43
    ADD_ASSIGN  décalage et aller à l'état 44
    SUB_ASSIGN  décalage et aller à l'état 45
    INCREMENT   décalage et aller à l'état 49
    DECREMENT   décalage et aller à l'état 50
    '='         décalage et aller à l'état 46

    assign_op  aller à l'état 51


État 23

   52 sub_decl: array_index .

    $défaut  réduction par utilisation de la règle 52 (sub_decl)


État 24

   96 array_index: IDENTIFIER '[' . condition ']'

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 58
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 25

   78 lhs: IDENTIFIER .

    $défaut  réduction par utilisation de la règle 78 (lhs)


État 26

   77 unary_expr: INCREMENT lhs .

    $défaut  réduction par utilisation de la règle 77 (unary_expr)


État 27

   76 unary_expr: DECREMENT lhs .

    $défaut  réduction par utilisation de la règle 76 (unary_expr)


État 28

   15 type_specifier: SHORT INT .

    $défaut  réduction par utilisation de la règle 15 (type_specifier)


État 29

   18 type_specifier: LONG INT .

    $défaut  réduction par utilisation de la règle 18 (type_specifier)


État 30

   20 type_specifier: LONG_LONG INT .

    $défaut  réduction par utilisation de la règle 20 (type_specifier)


État 31

    0 $accept: starter $end .

    $défaut  accepter


État 32

    1 starter: starter builder .

    $défaut  réduction par utilisation de la règle 1 (starter)


État 33

    5 function: type IDENTIFIER . '(' argument_list ')' bloc_stmt
   51 sub_decl: IDENTIFIER .
   78 lhs: IDENTIFIER .
   96 array_index: IDENTIFIER . '[' condition ']'

    '('  décalage et aller à l'état 63
    '['  décalage et aller à l'état 24

    ','       réduction par utilisation de la règle 51 (sub_decl)
    ';'       réduction par utilisation de la règle 51 (sub_decl)
    $défaut  réduction par utilisation de la règle 78 (lhs)


État 34

   45 declaration: type declaration_list . ';'
   48 declaration_list: declaration_list . ',' sub_decl

    ','  décalage et aller à l'état 39
    ';'  décalage et aller à l'état 64


État 35

   73 assignment_expr: unary_expr . assign_op unary_expr

    MUL_ASSIGN  décalage et aller à l'état 41
    DIV_ASSIGN  décalage et aller à l'état 42
    MOD_ASSIGN  décalage et aller à l'état 43
    ADD_ASSIGN  décalage et aller à l'état 44
    SUB_ASSIGN  décalage et aller à l'état 45
    '='         décalage et aller à l'état 46

    assign_op  aller à l'état 48


État 36

    8 pointer: '*' . pointer
    9        | '*' .

    '*'  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 9 (pointer)

    pointer  aller à l'état 65


État 37

    6 type: data_type pointer .

    $défaut  réduction par utilisation de la règle 6 (type)


État 38

   10 data_type: sign_specifier type_specifier .

    $défaut  réduction par utilisation de la règle 10 (data_type)


État 39

   48 declaration_list: declaration_list ',' . sub_decl

    IDENTIFIER  décalage et aller à l'état 1
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3

    sub_decl         aller à l'état 66
    assignment_expr  aller à l'état 20
    unary_expr       aller à l'état 35
    lhs              aller à l'état 22
    array_index      aller à l'état 23


État 40

   46 declaration: declaration_list ';' .

    $défaut  réduction par utilisation de la règle 46 (declaration)


État 41

   82 assign_op: MUL_ASSIGN .

    $défaut  réduction par utilisation de la règle 82 (assign_op)


État 42

   83 assign_op: DIV_ASSIGN .

    $défaut  réduction par utilisation de la règle 83 (assign_op)


État 43

   84 assign_op: MOD_ASSIGN .

    $défaut  réduction par utilisation de la règle 84 (assign_op)


État 44

   80 assign_op: ADD_ASSIGN .

    $défaut  réduction par utilisation de la règle 80 (assign_op)


État 45

   81 assign_op: SUB_ASSIGN .

    $défaut  réduction par utilisation de la règle 81 (assign_op)


État 46

   79 assign_op: '=' .

    $défaut  réduction par utilisation de la règle 79 (assign_op)


État 47

   47 declaration: unary_expr ';' .

    $défaut  réduction par utilisation de la règle 47 (declaration)


État 48

   73 assignment_expr: unary_expr assign_op . unary_expr

    IDENTIFIER  décalage et aller à l'état 25
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3

    unary_expr  aller à l'état 67
    lhs         aller à l'état 68


État 49

   74 unary_expr: lhs INCREMENT .

    $défaut  réduction par utilisation de la règle 74 (unary_expr)


État 50

   75 unary_expr: lhs DECREMENT .

    $défaut  réduction par utilisation de la règle 75 (unary_expr)


État 51

   69 assignment_expr: lhs assign_op . arithmetic_expr
   70                | lhs assign_op . array_index
   71                | lhs assign_op . function_call
   72                | lhs assign_op . unary_expr

    IDENTIFIER    décalage et aller à l'état 69
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    unary_expr       aller à l'état 70
    lhs              aller à l'état 68
    arithmetic_expr  aller à l'état 71
    constant         aller à l'état 62
    array_index      aller à l'état 72
    function_call    aller à l'état 73


État 52

   78 lhs: IDENTIFIER .
   92 arithmetic_expr: IDENTIFIER .

    MUL_ASSIGN  réduction par utilisation de la règle 78 (lhs)
    DIV_ASSIGN  réduction par utilisation de la règle 78 (lhs)
    MOD_ASSIGN  réduction par utilisation de la règle 78 (lhs)
    ADD_ASSIGN  réduction par utilisation de la règle 78 (lhs)
    SUB_ASSIGN  réduction par utilisation de la règle 78 (lhs)
    INCREMENT   réduction par utilisation de la règle 78 (lhs)
    DECREMENT   réduction par utilisation de la règle 78 (lhs)
    '='         réduction par utilisation de la règle 78 (lhs)
    $défaut    réduction par utilisation de la règle 92 (arithmetic_expr)


État 53

   94 constant: DEC_CONSTANT .

    $défaut  réduction par utilisation de la règle 94 (constant)


État 54

   95 constant: HEX_CONSTANT .

    $défaut  réduction par utilisation de la règle 95 (constant)


État 55

   91 arithmetic_expr: '-' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 75
    constant         aller à l'état 62


État 56

   65 condition: '!' . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 76
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 57

   90 arithmetic_expr: '(' . arithmetic_expr ')'

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 77
    constant         aller à l'état 62


État 58

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition
   96 array_index: IDENTIFIER '[' condition . ']'

    LOGICAL_AND  décalage et aller à l'état 78
    LOGICAL_OR   décalage et aller à l'état 79
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85
    ']'          décalage et aller à l'état 86


État 59

   67 condition: assignment_expr .

    $défaut  réduction par utilisation de la règle 67 (condition)


État 60

   68 condition: unary_expr .
   73 assignment_expr: unary_expr . assign_op unary_expr

    MUL_ASSIGN  décalage et aller à l'état 41
    DIV_ASSIGN  décalage et aller à l'état 42
    MOD_ASSIGN  décalage et aller à l'état 43
    ADD_ASSIGN  décalage et aller à l'état 44
    SUB_ASSIGN  décalage et aller à l'état 45
    '='         décalage et aller à l'état 46

    $défaut  réduction par utilisation de la règle 68 (condition)

    assign_op  aller à l'état 48


État 61

   66 condition: arithmetic_expr .
   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr

    '+'  décalage et aller à l'état 87
    '-'  décalage et aller à l'état 88
    '*'  décalage et aller à l'état 89
    '/'  décalage et aller à l'état 90
    '%'  décalage et aller à l'état 91

    $défaut  réduction par utilisation de la règle 66 (condition)


État 62

   93 arithmetic_expr: constant .

    $défaut  réduction par utilisation de la règle 93 (arithmetic_expr)


État 63

    5 function: type IDENTIFIER '(' . argument_list ')' bloc_stmt

    SHORT      décalage et aller à l'état 4
    INT        décalage et aller à l'état 5
    LONG       décalage et aller à l'état 6
    LONG_LONG  décalage et aller à l'état 7
    SIGNED     décalage et aller à l'état 8
    UNSIGNED   décalage et aller à l'état 9

    $défaut  réduction par utilisation de la règle 22 (argument_list)

    type            aller à l'état 92
    data_type       aller à l'état 14
    sign_specifier  aller à l'état 15
    type_specifier  aller à l'état 16
    argument_list   aller à l'état 93
    arguments       aller à l'état 94
    arg             aller à l'état 95


État 64

   45 declaration: type declaration_list ';' .

    $défaut  réduction par utilisation de la règle 45 (declaration)


État 65

    8 pointer: '*' pointer .

    $défaut  réduction par utilisation de la règle 8 (pointer)


État 66

   48 declaration_list: declaration_list ',' sub_decl .

    $défaut  réduction par utilisation de la règle 48 (declaration_list)


État 67

   73 assignment_expr: unary_expr assign_op unary_expr .

    $défaut  réduction par utilisation de la règle 73 (assignment_expr)


État 68

   74 unary_expr: lhs . INCREMENT
   75           | lhs . DECREMENT

    INCREMENT  décalage et aller à l'état 49
    DECREMENT  décalage et aller à l'état 50


État 69

   78 lhs: IDENTIFIER .
   92 arithmetic_expr: IDENTIFIER .
   96 array_index: IDENTIFIER . '[' condition ']'
   97 function_call: IDENTIFIER . '(' parameter_list ')'
   98              | IDENTIFIER . '(' ')'

    '('  décalage et aller à l'état 96
    '['  décalage et aller à l'état 24

    INCREMENT  réduction par utilisation de la règle 78 (lhs)
    DECREMENT  réduction par utilisation de la règle 78 (lhs)
    $défaut   réduction par utilisation de la règle 92 (arithmetic_expr)


État 70

   72 assignment_expr: lhs assign_op unary_expr .

    $défaut  réduction par utilisation de la règle 72 (assignment_expr)


État 71

   69 assignment_expr: lhs assign_op arithmetic_expr .
   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr

    '+'  décalage et aller à l'état 87
    '-'  décalage et aller à l'état 88
    '*'  décalage et aller à l'état 89
    '/'  décalage et aller à l'état 90
    '%'  décalage et aller à l'état 91

    $défaut  réduction par utilisation de la règle 69 (assignment_expr)


État 72

   70 assignment_expr: lhs assign_op array_index .

    $défaut  réduction par utilisation de la règle 70 (assignment_expr)


État 73

   71 assignment_expr: lhs assign_op function_call .

    $défaut  réduction par utilisation de la règle 71 (assignment_expr)


État 74

   92 arithmetic_expr: IDENTIFIER .

    $défaut  réduction par utilisation de la règle 92 (arithmetic_expr)


État 75

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr
   91                | '-' arithmetic_expr .

    $défaut  réduction par utilisation de la règle 91 (arithmetic_expr)


État 76

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition
   65          | '!' condition .

    $défaut  réduction par utilisation de la règle 65 (condition)


État 77

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr
   90                | '(' arithmetic_expr . ')'

    '+'  décalage et aller à l'état 87
    '-'  décalage et aller à l'état 88
    '*'  décalage et aller à l'état 89
    '/'  décalage et aller à l'état 90
    '%'  décalage et aller à l'état 91
    ')'  décalage et aller à l'état 97


État 78

   63 condition: condition LOGICAL_AND . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 98
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 79

   64 condition: condition LOGICAL_OR . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 99
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 80

   59 condition: condition EQ . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 100
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 81

   60 condition: condition NOT_EQ . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 101
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 82

   58 condition: condition '<' . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 102
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 83

   57 condition: condition '>' . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 103
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 84

   61 condition: condition L_EQ . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 104
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 85

   62 condition: condition G_EQ . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 105
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 86

   96 array_index: IDENTIFIER '[' condition ']' .

    $défaut  réduction par utilisation de la règle 96 (array_index)


État 87

   85 arithmetic_expr: arithmetic_expr '+' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 106
    constant         aller à l'état 62


État 88

   86 arithmetic_expr: arithmetic_expr '-' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 107
    constant         aller à l'état 62


État 89

   87 arithmetic_expr: arithmetic_expr '*' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 108
    constant         aller à l'état 62


État 90

   88 arithmetic_expr: arithmetic_expr '/' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 109
    constant         aller à l'état 62


État 91

   89 arithmetic_expr: arithmetic_expr '%' . arithmetic_expr

    IDENTIFIER    décalage et aller à l'état 74
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    '-'           décalage et aller à l'état 55
    '('           décalage et aller à l'état 57

    arithmetic_expr  aller à l'état 110
    constant         aller à l'état 62


État 92

   25 arg: type . IDENTIFIER

    IDENTIFIER  décalage et aller à l'état 111


État 93

    5 function: type IDENTIFIER '(' argument_list . ')' bloc_stmt

    ')'  décalage et aller à l'état 112


État 94

   21 argument_list: arguments .
   23 arguments: arguments . ',' arg

    ','  décalage et aller à l'état 113

    $défaut  réduction par utilisation de la règle 21 (argument_list)


État 95

   24 arguments: arg .

    $défaut  réduction par utilisation de la règle 24 (arguments)


État 96

   97 function_call: IDENTIFIER '(' . parameter_list ')'
   98              | IDENTIFIER '(' . ')'

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    STRING        décalage et aller à l'état 114
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57
    ')'           décalage et aller à l'état 115

    condition        aller à l'état 116
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62
    parameter_list   aller à l'état 117
    parameter        aller à l'état 118


État 97

   90 arithmetic_expr: '(' arithmetic_expr ')' .

    $défaut  réduction par utilisation de la règle 90 (arithmetic_expr)


État 98

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   63          | condition LOGICAL_AND condition .
   64          | condition . LOGICAL_OR condition

    EQ      décalage et aller à l'état 80
    NOT_EQ  décalage et aller à l'état 81
    '<'     décalage et aller à l'état 82
    '>'     décalage et aller à l'état 83
    L_EQ    décalage et aller à l'état 84
    G_EQ    décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 63 (condition)


État 99

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition
   64          | condition LOGICAL_OR condition .

    LOGICAL_AND  décalage et aller à l'état 78
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 64 (condition)


État 100

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   59          | condition EQ condition .
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    '<'   décalage et aller à l'état 82
    '>'   décalage et aller à l'état 83
    L_EQ  décalage et aller à l'état 84
    G_EQ  décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 59 (condition)


État 101

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   60          | condition NOT_EQ condition .
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    '<'   décalage et aller à l'état 82
    '>'   décalage et aller à l'état 83
    L_EQ  décalage et aller à l'état 84
    G_EQ  décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 60 (condition)


État 102

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   58          | condition '<' condition .
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    $défaut  réduction par utilisation de la règle 58 (condition)


État 103

   57 condition: condition . '>' condition
   57          | condition '>' condition .
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    $défaut  réduction par utilisation de la règle 57 (condition)


État 104

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   61          | condition L_EQ condition .
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    $défaut  réduction par utilisation de la règle 61 (condition)


État 105

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   62          | condition G_EQ condition .
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    $défaut  réduction par utilisation de la règle 62 (condition)


État 106

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   85                | arithmetic_expr '+' arithmetic_expr .
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr

    '*'  décalage et aller à l'état 89
    '/'  décalage et aller à l'état 90
    '%'  décalage et aller à l'état 91

    $défaut  réduction par utilisation de la règle 85 (arithmetic_expr)


État 107

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   86                | arithmetic_expr '-' arithmetic_expr .
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr

    '*'  décalage et aller à l'état 89
    '/'  décalage et aller à l'état 90
    '%'  décalage et aller à l'état 91

    $défaut  réduction par utilisation de la règle 86 (arithmetic_expr)


État 108

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   87                | arithmetic_expr '*' arithmetic_expr .
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr

    $défaut  réduction par utilisation de la règle 87 (arithmetic_expr)


État 109

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   88                | arithmetic_expr '/' arithmetic_expr .
   89                | arithmetic_expr . '%' arithmetic_expr

    $défaut  réduction par utilisation de la règle 88 (arithmetic_expr)


État 110

   85 arithmetic_expr: arithmetic_expr . '+' arithmetic_expr
   86                | arithmetic_expr . '-' arithmetic_expr
   87                | arithmetic_expr . '*' arithmetic_expr
   88                | arithmetic_expr . '/' arithmetic_expr
   89                | arithmetic_expr . '%' arithmetic_expr
   89                | arithmetic_expr '%' arithmetic_expr .

    $défaut  réduction par utilisation de la règle 89 (arithmetic_expr)


État 111

   25 arg: type IDENTIFIER .

    $défaut  réduction par utilisation de la règle 25 (arg)


État 112

    5 function: type IDENTIFIER '(' argument_list ')' . bloc_stmt

    '{'  décalage et aller à l'état 119

    bloc_stmt  aller à l'état 120


État 113

   23 arguments: arguments ',' . arg

    SHORT      décalage et aller à l'état 4
    INT        décalage et aller à l'état 5
    LONG       décalage et aller à l'état 6
    LONG_LONG  décalage et aller à l'état 7
    SIGNED     décalage et aller à l'état 8
    UNSIGNED   décalage et aller à l'état 9

    type            aller à l'état 92
    data_type       aller à l'état 14
    sign_specifier  aller à l'état 15
    type_specifier  aller à l'état 16
    arg             aller à l'état 121


État 114

  102 parameter: STRING .

    $défaut  réduction par utilisation de la règle 102 (parameter)


État 115

   98 function_call: IDENTIFIER '(' ')' .

    $défaut  réduction par utilisation de la règle 98 (function_call)


État 116

   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition
  101 parameter: condition .

    LOGICAL_AND  décalage et aller à l'état 78
    LOGICAL_OR   décalage et aller à l'état 79
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 101 (parameter)


État 117

   97 function_call: IDENTIFIER '(' parameter_list . ')'
   99 parameter_list: parameter_list . ',' parameter

    ','  décalage et aller à l'état 122
    ')'  décalage et aller à l'état 123


État 118

  100 parameter_list: parameter .

    $défaut  réduction par utilisation de la règle 100 (parameter_list)


État 119

   28 bloc_stmt: '{' . statements '}'

    $défaut  réduction par utilisation de la règle 30 (statements)

    statements  aller à l'état 124


État 120

    5 function: type IDENTIFIER '(' argument_list ')' bloc_stmt .

    $défaut  réduction par utilisation de la règle 5 (function)


État 121

   23 arguments: arguments ',' arg .

    $défaut  réduction par utilisation de la règle 23 (arguments)


État 122

   99 parameter_list: parameter_list ',' . parameter

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    STRING        décalage et aller à l'état 114
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 116
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62
    parameter        aller à l'état 125


État 123

   97 function_call: IDENTIFIER '(' parameter_list ')' .

    $défaut  réduction par utilisation de la règle 97 (function_call)


État 124

   28 bloc_stmt: '{' statements . '}'
   29 statements: statements . stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119
    '}'         décalage et aller à l'état 133

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 135
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 125

   99 parameter_list: parameter_list ',' parameter .

    $défaut  réduction par utilisation de la règle 99 (parameter_list)


État 126

   51 sub_decl: IDENTIFIER .
   78 lhs: IDENTIFIER .
   96 array_index: IDENTIFIER . '[' condition ']'
   97 function_call: IDENTIFIER . '(' parameter_list ')'
   98              | IDENTIFIER . '(' ')'

    '('  décalage et aller à l'état 96
    '['  décalage et aller à l'état 24

    ','       réduction par utilisation de la règle 51 (sub_decl)
    ';'       réduction par utilisation de la règle 51 (sub_decl)
    $défaut  réduction par utilisation de la règle 78 (lhs)


État 127

   42 if_block: IF . '(' expression ')' stmt
   43         | IF . '(' expression ')' stmt ELSE stmt

    '('  décalage et aller à l'état 143


État 128

   40 for_block: FOR . '(' expression_stmt expression_stmt ')' stmt
   41          | FOR . '(' expression_stmt expression_stmt expression ')' stmt

    '('  décalage et aller à l'état 144


État 129

   44 while_block: WHILE . '(' expression ')' stmt

    '('  décalage et aller à l'état 145


État 130

   37 single_stmt: CONTINUE . ';'

    ';'  décalage et aller à l'état 146


État 131

   38 single_stmt: BREAK . ';'

    ';'  décalage et aller à l'état 147


État 132

   36 single_stmt: RETURN . ';'
   39            | RETURN . condition ';'

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57
    ';'           décalage et aller à l'état 148

    condition        aller à l'état 149
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 133

   28 bloc_stmt: '{' statements '}' .

    $défaut  réduction par utilisation de la règle 28 (bloc_stmt)


État 134

   45 declaration: type . declaration_list ';'

    IDENTIFIER  décalage et aller à l'état 1
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3

    declaration_list  aller à l'état 34
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 35
    lhs               aller à l'état 22
    array_index       aller à l'état 23


État 135

   29 statements: statements stmt .

    $défaut  réduction par utilisation de la règle 29 (statements)


État 136

   26 stmt: bloc_stmt .

    $défaut  réduction par utilisation de la règle 26 (stmt)


État 137

   27 stmt: single_stmt .

    $défaut  réduction par utilisation de la règle 27 (stmt)


État 138

   32 single_stmt: for_block .

    $défaut  réduction par utilisation de la règle 32 (single_stmt)


État 139

   31 single_stmt: if_block .

    $défaut  réduction par utilisation de la règle 31 (single_stmt)


État 140

   33 single_stmt: while_block .

    $défaut  réduction par utilisation de la règle 33 (single_stmt)


État 141

   34 single_stmt: declaration .

    $défaut  réduction par utilisation de la règle 34 (single_stmt)


État 142

   35 single_stmt: function_call . ';'

    ';'  décalage et aller à l'état 150


État 143

   42 if_block: IF '(' . expression ')' stmt
   43         | IF '(' . expression ')' stmt ELSE stmt

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    expression       aller à l'état 151
    condition        aller à l'état 152
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 144

   40 for_block: FOR '(' . expression_stmt expression_stmt ')' stmt
   41          | FOR '(' . expression_stmt expression_stmt expression ')' stmt

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57
    ';'           décalage et aller à l'état 153

    expression_stmt  aller à l'état 154
    expression       aller à l'état 155
    condition        aller à l'état 152
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 145

   44 while_block: WHILE '(' . expression ')' stmt

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    expression       aller à l'état 156
    condition        aller à l'état 152
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 146

   37 single_stmt: CONTINUE ';' .

    $défaut  réduction par utilisation de la règle 37 (single_stmt)


État 147

   38 single_stmt: BREAK ';' .

    $défaut  réduction par utilisation de la règle 38 (single_stmt)


État 148

   36 single_stmt: RETURN ';' .

    $défaut  réduction par utilisation de la règle 36 (single_stmt)


État 149

   39 single_stmt: RETURN condition . ';'
   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    LOGICAL_AND  décalage et aller à l'état 78
    LOGICAL_OR   décalage et aller à l'état 79
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85
    ';'          décalage et aller à l'état 157


État 150

   35 single_stmt: function_call ';' .

    $défaut  réduction par utilisation de la règle 35 (single_stmt)


État 151

   42 if_block: IF '(' expression . ')' stmt
   43         | IF '(' expression . ')' stmt ELSE stmt
   55 expression: expression . ',' condition

    ','  décalage et aller à l'état 158
    ')'  décalage et aller à l'état 159


État 152

   56 expression: condition .
   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    LOGICAL_AND  décalage et aller à l'état 78
    LOGICAL_OR   décalage et aller à l'état 79
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 56 (expression)


État 153

   54 expression_stmt: ';' .

    $défaut  réduction par utilisation de la règle 54 (expression_stmt)


État 154

   40 for_block: FOR '(' expression_stmt . expression_stmt ')' stmt
   41          | FOR '(' expression_stmt . expression_stmt expression ')' stmt

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57
    ';'           décalage et aller à l'état 153

    expression_stmt  aller à l'état 160
    expression       aller à l'état 155
    condition        aller à l'état 152
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 155

   53 expression_stmt: expression . ';'
   55 expression: expression . ',' condition

    ','  décalage et aller à l'état 158
    ';'  décalage et aller à l'état 161


État 156

   44 while_block: WHILE '(' expression . ')' stmt
   55 expression: expression . ',' condition

    ','  décalage et aller à l'état 158
    ')'  décalage et aller à l'état 162


État 157

   39 single_stmt: RETURN condition ';' .

    $défaut  réduction par utilisation de la règle 39 (single_stmt)


État 158

   55 expression: expression ',' . condition

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57

    condition        aller à l'état 163
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 159

   42 if_block: IF '(' expression ')' . stmt
   43         | IF '(' expression ')' . stmt ELSE stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 164
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 160

   40 for_block: FOR '(' expression_stmt expression_stmt . ')' stmt
   41          | FOR '(' expression_stmt expression_stmt . expression ')' stmt

    IDENTIFIER    décalage et aller à l'état 52
    DEC_CONSTANT  décalage et aller à l'état 53
    HEX_CONSTANT  décalage et aller à l'état 54
    INCREMENT     décalage et aller à l'état 2
    DECREMENT     décalage et aller à l'état 3
    '-'           décalage et aller à l'état 55
    '!'           décalage et aller à l'état 56
    '('           décalage et aller à l'état 57
    ')'           décalage et aller à l'état 165

    expression       aller à l'état 166
    condition        aller à l'état 152
    assignment_expr  aller à l'état 59
    unary_expr       aller à l'état 60
    lhs              aller à l'état 22
    arithmetic_expr  aller à l'état 61
    constant         aller à l'état 62


État 161

   53 expression_stmt: expression ';' .

    $défaut  réduction par utilisation de la règle 53 (expression_stmt)


État 162

   44 while_block: WHILE '(' expression ')' . stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 167
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 163

   55 expression: expression ',' condition .
   57 condition: condition . '>' condition
   58          | condition . '<' condition
   59          | condition . EQ condition
   60          | condition . NOT_EQ condition
   61          | condition . L_EQ condition
   62          | condition . G_EQ condition
   63          | condition . LOGICAL_AND condition
   64          | condition . LOGICAL_OR condition

    LOGICAL_AND  décalage et aller à l'état 78
    LOGICAL_OR   décalage et aller à l'état 79
    EQ           décalage et aller à l'état 80
    NOT_EQ       décalage et aller à l'état 81
    '<'          décalage et aller à l'état 82
    '>'          décalage et aller à l'état 83
    L_EQ         décalage et aller à l'état 84
    G_EQ         décalage et aller à l'état 85

    $défaut  réduction par utilisation de la règle 55 (expression)


État 164

   42 if_block: IF '(' expression ')' stmt .
   43         | IF '(' expression ')' stmt . ELSE stmt

    ELSE  décalage et aller à l'état 168

    $défaut  réduction par utilisation de la règle 42 (if_block)


État 165

   40 for_block: FOR '(' expression_stmt expression_stmt ')' . stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 169
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 166

   41 for_block: FOR '(' expression_stmt expression_stmt expression . ')' stmt
   55 expression: expression . ',' condition

    ','  décalage et aller à l'état 158
    ')'  décalage et aller à l'état 170


État 167

   44 while_block: WHILE '(' expression ')' stmt .

    $défaut  réduction par utilisation de la règle 44 (while_block)


État 168

   43 if_block: IF '(' expression ')' stmt ELSE . stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 171
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 169

   40 for_block: FOR '(' expression_stmt expression_stmt ')' stmt .

    $défaut  réduction par utilisation de la règle 40 (for_block)


État 170

   41 for_block: FOR '(' expression_stmt expression_stmt expression ')' . stmt

    IDENTIFIER  décalage et aller à l'état 126
    INCREMENT   décalage et aller à l'état 2
    DECREMENT   décalage et aller à l'état 3
    SHORT       décalage et aller à l'état 4
    INT         décalage et aller à l'état 5
    LONG        décalage et aller à l'état 6
    LONG_LONG   décalage et aller à l'état 7
    SIGNED      décalage et aller à l'état 8
    UNSIGNED    décalage et aller à l'état 9
    IF          décalage et aller à l'état 127
    FOR         décalage et aller à l'état 128
    WHILE       décalage et aller à l'état 129
    CONTINUE    décalage et aller à l'état 130
    BREAK       décalage et aller à l'état 131
    RETURN      décalage et aller à l'état 132
    '{'         décalage et aller à l'état 119

    type              aller à l'état 134
    data_type         aller à l'état 14
    sign_specifier    aller à l'état 15
    type_specifier    aller à l'état 16
    stmt              aller à l'état 172
    bloc_stmt         aller à l'état 136
    single_stmt       aller à l'état 137
    for_block         aller à l'état 138
    if_block          aller à l'état 139
    while_block       aller à l'état 140
    declaration       aller à l'état 141
    declaration_list  aller à l'état 18
    sub_decl          aller à l'état 19
    assignment_expr   aller à l'état 20
    unary_expr        aller à l'état 21
    lhs               aller à l'état 22
    array_index       aller à l'état 23
    function_call     aller à l'état 142


État 171

   43 if_block: IF '(' expression ')' stmt ELSE stmt .

    $défaut  réduction par utilisation de la règle 43 (if_block)


État 172

   41 for_block: FOR '(' expression_stmt expression_stmt expression ')' stmt .

    $défaut  réduction par utilisation de la règle 41 (for_block)
